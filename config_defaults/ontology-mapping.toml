# ### Runnables ###
#
# The mappings here specify rules that annotate all descendant overrides of
# virtual runnable methods so that when we encounter them in the crossref
# process that we are able to generate `RunnableConstructor` slot edges to their
# constructors and corresponding `RunnableMethod` slot edges back from the
# constructors to the runnable methods.  These will be followed by the
# "traverse" command instead of getting into the infrastructure boilerplate
# around runnables.

[pretty."nsIRunnable::Run"]
runnable = true

[pretty."mozilla::dom::WorkerRunnable::WorkerRun"]
runnable = true

[pretty."mozilla::dom::WorkerMainThreadRunnable::MainThreadRun"]
runnable = true

[pretty."mozilla::dom::WorkerThreadProxySyncRunnable::RunOnMainThread"]
runnable = true

# ### Cycle Collection ###
[[pretty."nsXPCOMCycleCollectionParticipant".label_field_uses.labels]]
context_sym_suffix = "::cycleCollection::TraverseNative"
label = "cc:traverse"
[[pretty."nsXPCOMCycleCollectionParticipant".label_field_uses.labels]]
context_sym_suffix = "::cycleCollection::Unlink"
label = "cc:unlink"

# ### Label Testing ###
#
# Okay, so, uh, these are only for testing.



# ### Pointer Types ###
#
# These inform our processing of class fields

[types."nsCOMPtr".pointer]
kind = "strong"

[types."RefPtr".pointer]
kind = "strong"

[types."SafeRefPtr".pointer]
kind = "strong"

[types."UniquePtr".pointer]
kind = "unique"

[types."WeakPtr".pointer]
kind = "weak"

[types."std::shared_ptr".pointer]
kind = "strong"

[types."std::unique_ptr".pointer]
kind = "unique"

[types."std::weak_ptr".pointer]
kind = "weak"
