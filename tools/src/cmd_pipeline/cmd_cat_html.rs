use async_trait::async_trait;
use lol_html::{element, rewrite_str, RewriteStrSettings, html_content::ContentType};
use structopt::StructOpt;

use super::interface::{PipelineCommand, PipelineValues, TextFile};
use crate::{
    abstract_server::{AbstractServer, HtmlFileRoot, Result},
};

/// Dump the contents of a HTML file for a (source) file or rendered directory
/// listing from disk in its entirety, applying minimal normalization to
/// compensate for datestamps or specific revision data.
///
/// Intended exclusively for regression testing and in particular to provide
/// coverage for directory listings and semi-generated files like "help.html"
/// and "settings.html" where we want to audit changes to the file in their
/// entirety but we don't want to have N copies of the searchfox HTML super
/// structure.  We would expect to use this command for at most a few source
/// files to validate where the source listing joins to the HTML super structure
/// but would expect to use "show-html" for most "checks" so that they can be
/// much more targeted (than having potentially massive diffs that are
/// constantly including the entirety of a generated page with many irrelevant
/// changes to the specific purpose of the check).
///
/// Differs from show-html which is about excerpting source lines and which has
/// a separate "prod-filter" helper for production "checks".
#[derive(Debug, StructOpt)]
pub struct CatHtml {
    /// Tree-relative source file path or directory.
    file: String,

    /// Is this a directory's HTML we want (instead of a source file)?
    #[structopt(short, long)]
    dir: bool,

    /// Is this a template's HTML we want?
    #[structopt(short, long)]
    template: bool,
}

#[derive(Debug)]
pub struct CatHtmlCommand {
    pub args: CatHtml,
}

// HTML normalization of our expected entire HTML files:
// - "This page was generated by Searchfox DATETIME": We wrap the
//   datetime in a spam with class "pretty-date" and attribute with key
//   "data-datetime".  We currently normalize by replacing it with a span
//   `<span>NORMALIZED</span>` which loses the extra attributes but we don't
//   care about that level of fidelity.
fn norm_html_file(s: String) -> String {
    let element_content_handlers = vec![
        element!(
            r#"span.pretty-date"#,
            |el| {
                el.replace("<span>NORMALIZED</span>", ContentType::Html);
                Ok(())
            }
        ),
    ];

    rewrite_str(
        &s,
        RewriteStrSettings {
            element_content_handlers,
            ..RewriteStrSettings::default()
        },
    )
    .unwrap()
}


#[async_trait]
impl PipelineCommand for CatHtmlCommand {
    async fn execute(
        &self,
        server: &Box<dyn AbstractServer + Send + Sync>,
        _input: PipelineValues,
    ) -> Result<PipelineValues> {
        let root = if self.args.dir {
            HtmlFileRoot::FormattedDir
        } else if self.args.template {
            HtmlFileRoot::FormattedTemplate
        } else {
            HtmlFileRoot::FormattedFile
        };
        let html_str = server.fetch_html(root, &self.args.file).await?;

        Ok(PipelineValues::TextFile(TextFile {
            mime_type: "text/html".to_string(),
            contents: norm_html_file(html_str),
        }))

    }
}
