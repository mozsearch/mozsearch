# GC Annotation

Function's structured record can contain the information about whether
the function can perform GC.

The data is generated by the hazard analysis jobs.
https://searchfox.org/firefox-main/rev/57fca9d512cb15cb3b3af4f746e8ff517524d4d2/taskcluster/kinds/hazard/kind.yml#59

The GC annotation step uses two artifacts from the job:
  * `allFunctions.txt`
  * `gcFunctions.txt`

`allFunctions.txt` contains the list of functions covered by the analysis, in the following format.

```
SYMBOL_NAME_1$PRETTY_NAME_1
SYMBOL_NAME_2$PRETTY_NAME_2
SYMBOL_NAME_3$PRETTY_NAME_3
...
```

`gcFunctions.txt` contains the list of function that can GC, in the following format,
where the first line is the function that can GC, and the following indented lines for
the call path to the possible GC.
GC functions are separated by an empty line.

```
GC Function: SYMBOL_NAME_1$PRETTY_NAME_1
    PRETTY_NAME_1_1
    PRETTY_NAME_1_2
    PRETTY_NAME_1_3
    (GC)

GC Function: SYMBOL_NAME_2$PRETTY_NAME_2
    PRETTY_NAME_2_1
    PRETTY_NAME_2_2
    PRETTY_NAME_2_3
    ...
    arbitrary function pointer NAME

...
```

The GC annotation step puts the information into the structured record of each analysis file.
This is done by `scripts/annotate-gc.sh` and `scripts/annotate-gc.py`.

If a function symbol is found only in `allFunctions.txt`, it's marked as `canGC` being `false`,
and if the function symbol is found in `gcFunctions.txt`, it's marked as `canGC` being `true`,
and `gcPath` being the call path.

If the function symbol is not found in any, no annotation is performed and the structured
record doesn't get `canGC` property.

The symbols in `allFunctions.txt` are `gcFunctions.txt` generated with gcc, and
the structured analysis records are generated with clang.  There can be some difference in
the symbols, and some functions such as lambda may not get GC annotation.
